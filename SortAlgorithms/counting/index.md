# 计数排序

> `计数排序` 是分布式排序；`分布式排序` 使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排序好的数组

> `计数排序` 使用一个用来存储每个元素在原始数组中出现次数的临时数组，在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组

![image text](./images/counting.drawio.svg)


- 循环排序

  - 循环遍历原始数组，找出原始数组中的最大值 `maxValue`

  - 创建一个临时数组，该数组的长度为 `maxValue + 1`

  - 循环遍历原始数组，并将原始数组中的值作为新数组的索引；如果该索引位置不存在，则给该索引位置 赋值为 `0`；该索引位置的值 `+1`；

    - `+1` 的原因，如果有多个重复的值，则索引位置重复， `+1` 表示出现的次数 `+1`次

    - 该索引位置对应的值代表该值在原始数组中出现的次数；索引是原始数组中的值

  - 取出临时数组中有值的索引，组成的数组即为已经排序好的数组；如果该位置的值 `>1`，则依次顺延
  ```js
    // 1 获取 array 的最大值 maxValue ，创建了新数组 counts = new Array( maxValue + 1 )
    // 2 循环 array ，将 counts[array[i]] 不存在，赋值 = 0； 无论是否存在都 counts[array[i]]++
    // 3 设置循环计数 sortIndex = 0 循环 counts
    // 4 counts[i] > 0 由于 counts[i] 可能大于1，即同一个元素出现了 n 次
    // while( 这个元素出现的次数 > 0 ) {
    //  array[sortIndex++] = 这个元素的索引 
    //  这个元素的索引--
    // }

  ````

- 计算复杂度

  - 它是用来排序整数的优秀算法（是一个 `整数排序算法`），时间复杂度为 `O(n+k)`；其中 `k` 是临时计数数组的大小

  - 需要更多的内存来存放临时数组